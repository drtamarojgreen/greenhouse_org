<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wix Permissions Logic Unit Tests</title>
    <style>
        body { font-family: sans-serif; padding: 1em; }
        #test-dom-container { border: 2px dashed #a0a0a0; padding: 1em; margin-top: 1em; }
        #test-dom { border: 1px solid #ccc; padding: 1em; }
        .log { margin: 0; padding: 2px 5px; }
        .log.pass { background-color: #e6ffed; }
        .log.fail { background-color: #ffe6e6; font-weight: bold; }
        .log.suite { background-color: #f0f0f0; margin-top: 1em; font-weight: bold; }
        .summary { padding: 10px; margin-top: 1em; font-size: 1.2em; }
        .summary.pass { background-color: #4CAF50; color: white; }
        .summary.fail { background-color: #F44336; color: white; }
    </style>
</head>
<body>
    <h1>Wix Permissions Logic Unit Tests</h1>
    <p>Open the browser console to see detailed test output. A summary is provided below.</p>
    <div id="results"></div>

    <!-- This container allows us to reset the DOM for rendering tests -->
    <div id="test-dom-container">
        <div id="test-dom">
            <h2>Simulated Page</h2>
            <!-- Native Elements -->
            <div id="conflictResolutionView">Conflict Resolution View</div>
            <div id="fullSchedulingCalendars">Full Scheduling Calendars</div>
            <div id="weeklyScheduleView">Weekly Schedule View</div>
            <div id="openMonthlyModalButton">Open Monthly Schedule</div>
            <div id="scheduleAppointmentForm">Schedule Appointment Form</div>

            <!-- HTML Component Containers -->
            <div id="dashboardLeftContainer" style="display: block;"></div>
            <div id="dashboardRightContainer" style="display: block;"></div>
            <div id="repeaterLeftContainer" style="display: block;"></div>
            <div id="repeaterRightContainer" style="display: block;"></div>
        </div>
    </div>

    <script>
    //================================================================
    // 1. MINI TEST FRAMEWORK (No external libraries)
    //================================================================
    const TestRunner = {
        suites: [],
        stats: { pass: 0, fail: 0 },

        describe(name, fn) {
            this.suites.push({ name, fn, tests: [], beforeEach: null });
            fn(); // Execute the suite function to collect tests
        },

        it(name, fn) {
            if (this.suites.length === 0) {
                console.error("Cannot call 'it' outside of a 'describe' block");
                return;
            }
            this.suites[this.suites.length - 1].tests.push({ name, fn });
        },

        beforeEach(fn) {
            if (this.suites.length === 0) {
                console.error("Cannot call 'beforeEach' outside of a 'describe' block");
                return;
            }
            this.suites[this.suites.length - 1].beforeEach = fn;
        },

        async run() {
            const resultsEl = document.getElementById('results');
            // Clear previous results
            resultsEl.innerHTML = '';
            this.stats = { pass: 0, fail: 0 };

            for (const suite of this.suites) {
                this.log(suite.name, 'suite');
                console.group(suite.name);
                for (const test of suite.tests) {
                    try {
                        if (suite.beforeEach) {
                            suite.beforeEach();
                        }
                        await test.fn();
                        this.log(`  [PASS] ${test.name}`, 'pass');
                        this.stats.pass++;
                    } catch (e) {
                        this.log(`  [FAIL] ${test.name}`, 'fail');
                        console.error(`Failed: ${test.name}`, e);
                        this.stats.fail++;
                    }
                }
                console.groupEnd();
            }
            this.summarize();
        },

        log(message, className) {
            const resultsEl = document.getElementById('results');
            const p = document.createElement('pre');
            p.className = `log ${className}`;
            p.textContent = message;
            resultsEl.appendChild(p);
        },

        summarize() {
            const summaryEl = document.createElement('div');
            summaryEl.textContent = `Complete: ${this.stats.pass} passed, ${this.stats.fail} failed.`;
            if (this.stats.fail > 0) {
                summaryEl.className = 'summary fail';
            } else {
                summaryEl.className = 'summary pass';
            }
            document.getElementById('results').appendChild(summaryEl);
        },

        assert: {
            isTrue(value, message = "Expected value to be true") {
                if (value !== true) throw new Error(message);
            },
            strictEqual(actual, expected, message = `Expected ${actual} to equal ${expected}`) {
                if (actual !== expected) throw new Error(message);
            },
            deepEqual(actual, expected, message = "Expected objects to be equal") {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    console.log("Actual:", actual);
                    console.log("Expected:", expected);
                    throw new Error(message);
                }
            }
        }
    };

    const assert = TestRunner.assert;

    //================================================================
    // 2. MOCKS, SPIES & UTILITIES
    //================================================================
    const initialTestDomHtml = document.getElementById('test-dom-container').innerHTML;
    function resetTestDom() {
        document.getElementById('test-dom-container').innerHTML = initialTestDomHtml;
    }

    const mocks = {
        wixUsers: null,
        wixWindow: null,
        $w: null,
        schedulerHost: null,
        wixUsersBackend: null,

        setup() {
            this.wixUsers = this.createWixUsersMock();
            this.wixWindow = this.createWixWindowMock();
            this.$w = this.create$wMock();
            this.schedulerHost = this.createSchedulerHostMock();
            this.wixUsersBackend = this.createWixUsersBackendMock();

            this.$w.elements['#schedulerHost'] = this.schedulerHost;
        },

        createWixUsersMock() {
            const mock = {
                currentUser: {
                    loggedIn: false,
                    getRoles: async () => []
                },
                _configure(loggedIn, roles = [], shouldReject = false) {
                    this.currentUser.loggedIn = loggedIn;
                    if (shouldReject) {
                        this.currentUser.getRoles = () => Promise.reject(new Error("Mock API failure"));
                    } else {
                        this.currentUser.getRoles = async () => roles.map(name => ({ name, description: name }));
                    }
                }
            };
            return mock;
        },

        createWixUsersBackendMock() {
            return this.createWixUsersMock();
        },

        createWixWindowMock() {
            return {
                history: [],
                openLightbox(name, data) {
                    this.history.push({ name, data });
                }
            };
        },

        create$wMock() {
            const mock = {
                elements: {},
                history: [],
                onReady: async (fn) => { await fn(); },
                select(selector) {
                    const element = this.elements[selector] || {
                        show: () => mock.history.push({ selector, action: 'show' }),
                        hide: () => mock.history.push({ selector, action: 'hide' }),
                    };
                    return element;
                }
            };
            const handler = (selector) => mock.select(selector);
            Object.assign(handler, mock);
            return handler;
        },

        createSchedulerHostMock() {
            return {
                history: [],
                _readyCallback: null,
                onReady(fn) { this._readyCallback = fn; },
                postMessage(message) { this.history.push(message); },
                _triggerReady() { if (this._readyCallback) { this._readyCallback(); } }
            };
        },

        reset() {
            Object.values(this).forEach(mock => {
                if (mock && mock.history) mock.history = [];
            });
            this.setup();
        }
    };

    //================================================================
    // 3. CODE UNDER TEST (Adapted from the markdown)
    //================================================================

    async function runVeloOnReadySimple(wixUsers, $w) {
        const currentUser = wixUsers.currentUser;
        let hasAdminAccess = false;

        try {
            if (currentUser.loggedIn) {
                const roles = await currentUser.getRoles();
                if (roles.some(role => role.name === "Administrator" || role.name === "Developer")) {
                    hasAdminAccess = true;
                }
            }
        } catch (error) {
            console.error("Error getting user roles:", error);
            hasAdminAccess = false; // Default to public view on error
        }

        if (hasAdminAccess) {
            $w('#conflictResolutionView').show();
            $w('#fullSchedulingCalendars').show();
            $w('#weeklyScheduleView').hide();
            $w('#openMonthlyModalButton').hide();
            $w('#scheduleAppointmentForm').hide();
        } else {
            $w('#weeklyScheduleView').show();
            $w('#openMonthlyModalButton').show();
            $w('#scheduleAppointmentForm').show();
            $w('#conflictResolutionView').hide();
            $w('#fullSchedulingCalendars').hide();
        }
    }

    async function runVeloOnReadyAdvanced(wixUsers, $w) {
        const schedulerHost = $w('#schedulerHost');
        const currentUser = wixUsers.currentUser;
        let simplifiedRole = 'public';

        try {
            if (currentUser.loggedIn) {
                const roles = await currentUser.getRoles();
                if (roles.some(role => role.name === "Administrator" || role.name === "Developer")) {
                    simplifiedRole = 'admin';
                }
            }
        } catch (error) {
            console.error("Error getting user roles:", error);
            simplifiedRole = 'public'; // Default to public on error
        }
<<<<<<< HEAD

=======
        
>>>>>>> main
        const message = {
            role: simplifiedRole,
            selectors: {
                dashboardLeft: '#dashboardLeftContainer',
                dashboardRight: '#dashboardRightContainer',
                repeaterLeft: '#repeaterLeftContainer',
                repeaterRight: '#repeaterRightContainer'
            }
        };

        schedulerHost.onReady(() => { schedulerHost.postMessage(message); });
        schedulerHost._triggerReady();
    }

    // --- scheduler.js logic ---
    let schedulerJsSpy = { lastFunctionCalled: null };
    function renderAdminView(selectors) {
        schedulerJsSpy.lastFunctionCalled = 'admin';
        document.querySelector(selectors.repeaterLeft).style.display = 'none';
        document.querySelector(selectors.repeaterRight).style.display = 'none';
        document.querySelector(selectors.dashboardLeft).style.display = 'block';
        document.querySelector(selectors.dashboardRight).style.display = 'block';
    }
    function renderPublicView(selectors) {
        schedulerJsSpy.lastFunctionCalled = 'public';
        document.querySelector(selectors.dashboardLeft).style.display = 'none';
        document.querySelector(selectors.dashboardRight).style.display = 'none';
        document.querySelector(selectors.repeaterLeft).style.display = 'block';
        document.querySelector(selectors.repeaterRight).style.display = 'block';
    }

    function handleSchedulerMessage(event) {
        if (!event || !event.data) return;
        const { role, selectors } = event.data;
        if (role === 'admin') {
            renderAdminView(selectors);
        } else {
            renderPublicView(selectors);
        }
    }

    async function getAdminData(wixUsersBackend) {
        const roles = await wixUsersBackend.currentUser.getRoles();
        const isAdmin = roles.some(role => role.name === "Administrator" || role.name === "Developer");

        if (!isAdmin) {
            throw new Error("Permission Denied: User is not an administrator.");
        }
        return { data: "sensitive admin data" };
    }


    //================================================================
    // 4. TEST SUITES
    //================================================================
    (async function() {
        // Clear suites to avoid duplication if script is run multiple times
        TestRunner.suites = [];

        TestRunner.describe('Velo Permissions: Simple (Native Elements)', () => {
            TestRunner.beforeEach(() => mocks.reset());

            TestRunner.it('should show admin view for "Administrator" role', async () => {
                mocks.wixUsers._configure(true, ['Administrator']);
                await runVeloOnReadySimple(mocks.wixUsers, mocks.$w);
                assert.deepEqual(mocks.$w.history.filter(c => c.action === 'show').map(c => c.selector).sort(), ['#conflictResolutionView', '#fullSchedulingCalendars'].sort());
            });

            TestRunner.it('should show admin view for "Developer" role', async () => {
                mocks.wixUsers._configure(true, ['Developer', 'Member']);
                await runVeloOnReadySimple(mocks.wixUsers, mocks.$w);
                assert.deepEqual(mocks.$w.history.filter(c => c.action === 'show').map(c => c.selector).sort(), ['#conflictResolutionView', '#fullSchedulingCalendars'].sort());
            });

            TestRunner.it('should show public view for a standard logged-in user', async () => {
                mocks.wixUsers._configure(true, ['Member']);
                await runVeloOnReadySimple(mocks.wixUsers, mocks.$w);
                assert.deepEqual(mocks.$w.history.filter(c => c.action === 'show').map(c => c.selector).sort(), ['#openMonthlyModalButton', '#scheduleAppointmentForm', '#weeklyScheduleView'].sort());
            });

            TestRunner.it('should show public view for an anonymous user', async () => {
                mocks.wixUsers._configure(false);
                await runVeloOnReadySimple(mocks.wixUsers, mocks.$w);
                assert.deepEqual(mocks.$w.history.filter(c => c.action === 'show').map(c => c.selector).sort(), ['#openMonthlyModalButton', '#scheduleAppointmentForm', '#weeklyScheduleView'].sort());
            });
        });

        TestRunner.describe('Velo Permissions: Advanced (HtmlComponent)', () => {
            TestRunner.beforeEach(() => mocks.reset());

            TestRunner.it('should post "admin" role for "Administrator"', async () => {
                mocks.wixUsers._configure(true, ['Administrator']);
                await runVeloOnReadyAdvanced(mocks.wixUsers, mocks.$w);
                assert.strictEqual(mocks.schedulerHost.history[0].role, 'admin');
            });

            TestRunner.it('should post "admin" role for "Developer"', async () => {
                mocks.wixUsers._configure(true, ['Developer']);
                await runVeloOnReadyAdvanced(mocks.wixUsers, mocks.$w);
                assert.strictEqual(mocks.schedulerHost.history[0].role, 'admin');
            });

            TestRunner.it('should post "public" role for standard user', async () => {
                mocks.wixUsers._configure(true, ['Member']);
                await runVeloOnReadyAdvanced(mocks.wixUsers, mocks.$w);
                assert.strictEqual(mocks.schedulerHost.history[0].role, 'public');
            });

            TestRunner.it('should post "public" role for anonymous user', async () => {
                mocks.wixUsers._configure(false);
                await runVeloOnReadyAdvanced(mocks.wixUsers, mocks.$w);
                assert.strictEqual(mocks.schedulerHost.history[0].role, 'public');
            });
        });

        TestRunner.describe('scheduler.js: Message Handling', () => {
            TestRunner.beforeEach(() => { schedulerJsSpy.lastFunctionCalled = null; });

            TestRunner.it('should call renderAdminView when role is "admin"', () => {
                handleSchedulerMessage({ data: { role: 'admin', selectors: {} } });
                assert.strictEqual(schedulerJsSpy.lastFunctionCalled, 'admin');
            });

            TestRunner.it('should call renderPublicView when role is "public"', () => {
                handleSchedulerMessage({ data: { role: 'public', selectors: {} } });
                assert.strictEqual(schedulerJsSpy.lastFunctionCalled, 'public');
            });
        });

        TestRunner.describe('Backend Permissions (.jsw)', () => {
            TestRunner.beforeEach(() => mocks.reset());

            TestRunner.it('should return data for "Administrator"', async () => {
                mocks.wixUsersBackend._configure(true, ['Administrator']);
                const result = await getAdminData(mocks.wixUsersBackend);
                assert.deepEqual(result, { data: "sensitive admin data" });
            });

            TestRunner.it('should return data for "Developer"', async () => {
                mocks.wixUsersBackend._configure(true, ['Developer']);
                const result = await getAdminData(mocks.wixUsersBackend);
                assert.deepEqual(result, { data: "sensitive admin data" });
            });

            TestRunner.it('should throw an error for a standard user', async () => {
                mocks.wixUsersBackend._configure(true, ['Member']);
                let caughtError = null;
                try { await getAdminData(mocks.wixUsersBackend); } catch (e) { caughtError = e; }
                assert.isTrue(caughtError !== null);
                assert.strictEqual(caughtError.message, "Permission Denied: User is not an administrator.");
            });

            TestRunner.it('should throw an error for an anonymous user', async () => {
                mocks.wixUsersBackend._configure(false);
                let caughtError = null;
                try { await getAdminData(mocks.wixUsersBackend); } catch (e) { caughtError = e; }
                assert.isTrue(caughtError !== null);
                assert.strictEqual(caughtError.message, "Permission Denied: User is not an administrator.");
            });
        });

        // New, more comprehensive tests
        TestRunner.describe('scheduler.js: DOM Rendering', () => {
            const selectors = { dashboardLeft: '#dashboardLeftContainer', dashboardRight: '#dashboardRightContainer', repeaterLeft: '#repeaterLeftContainer', repeaterRight: '#repeaterRightContainer' };
            TestRunner.beforeEach(() => resetTestDom());

            TestRunner.it('should show admin containers and hide public containers for admin role', () => {
                renderAdminView(selectors);
                assert.strictEqual(document.querySelector(selectors.dashboardLeft).style.display, 'block');
                assert.strictEqual(document.querySelector(selectors.repeaterLeft).style.display, 'none');
            });

            TestRunner.it('should show public containers and hide admin containers for public role', () => {
                renderPublicView(selectors);
                assert.strictEqual(document.querySelector(selectors.repeaterLeft).style.display, 'block');
                assert.strictEqual(document.querySelector(selectors.dashboardLeft).style.display, 'none');
            });
        });

        TestRunner.describe('Velo Permissions: Error & Edge Cases', () => {
            TestRunner.beforeEach(() => mocks.reset());

            TestRunner.it('should default to public view if getRoles() fails (Simple)', async () => {
                const originalConsoleError = console.error;
                console.error = () => {}; // Suppress expected error log
                mocks.wixUsers._configure(true, [], true);
                await runVeloOnReadySimple(mocks.wixUsers, mocks.$w);
                console.error = originalConsoleError; // Restore
                assert.deepEqual(mocks.$w.history.filter(c => c.action === 'show').map(c => c.selector).sort(), ['#openMonthlyModalButton', '#scheduleAppointmentForm', '#weeklyScheduleView'].sort());
            });

            TestRunner.it('should post "public" role if getRoles() fails (Advanced)', async () => {
                const originalConsoleError = console.error;
                console.error = () => {}; // Suppress expected error log
                mocks.wixUsers._configure(true, [], true);
                await runVeloOnReadyAdvanced(mocks.wixUsers, mocks.$w);
                console.error = originalConsoleError; // Restore
                assert.strictEqual(mocks.schedulerHost.history[0].role, 'public');
            });
        });

        TestRunner.describe('scheduler.js: Malformed Messages', () => {
            TestRunner.beforeEach(() => { schedulerJsSpy.lastFunctionCalled = null; resetTestDom(); });

            TestRunner.it('should not throw an error for a null event or data', () => {
                handleSchedulerMessage(null);
                handleSchedulerMessage({ data: null });
                assert.isTrue(true);
            });

            TestRunner.it('should default to public view for a message with no role property', () => {
                handleSchedulerMessage({ data: { selectors: { repeaterLeft: '#repeaterLeftContainer', repeaterRight: '#repeaterRightContainer', dashboardLeft: '#dashboardLeftContainer', dashboardRight: '#dashboardRightContainer'} } });
                assert.strictEqual(schedulerJsSpy.lastFunctionCalled, 'public');
            });
        });

        // Run all defined tests
        TestRunner.run();
    })();
    </script>
</body>
</html>
