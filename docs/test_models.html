<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greenhouse Live Simulator</title>

    <!-- Mandatory Production Stylesheets -->
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/style.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/image.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/effects.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/pages.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/tech.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/model.css">
    <link rel="stylesheet" href="https://drtamarojgreen.github.io/greenhouse_org/css/models_toc.css">

    <!-- Mandatory Production Scripts -->
    <script src="js/GreenhouseDependencyManager.js"></script>
    <script src="js/GreenhouseUtils.js"></script>
    <script src="js/greenhouse.js"></script>

    <style>
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin: 0; padding: 0; background-color: #f4f7f6;
            display: flex; flex-direction: column; align-items: center; min-height: 100vh;
        }
        header {
            background-color: #fff; width: 100%; padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; align-items: center;
            z-index: 1000; border-bottom: 2px solid #4ca1af;
        }
        .harness-title { color: #4ca1af; font-size: 24px; font-weight: 700; margin: 0 0 15px 0; }
        .controls { display: flex; gap: 15px; align-items: center; }
        select { padding: 10px 15px; font-size: 15px; border-radius: 6px; border: 1px solid #ddd; width: 320px; outline: none; }
        .btn { padding: 10px 20px; font-size: 14px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; }
        #run-suite-tests { background-color: #4ca1af; color: white; }
        #model-container { width: 100%; flex-grow: 1; position: relative; background-color: #fff; padding-top: 20px; }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.98);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10000; font-size: 20px; font-weight: bold; color: #4ca1af;
        }
        .spinner {
            width: 60px; height: 60px; border: 6px solid rgba(76, 161, 175, 0.1); border-top: 6px solid #4ca1af;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 25px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .wixui-section { display: block; width: 100%; min-height: 600px; }
    </style>
</head>
<body>

<div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loader-message">Initializing Live Site Environment...</div>
</div>

<header>
    <h1 class="harness-title">Greenhouse Live Simulator</h1>
    <div class="controls">
        <select id="model-selector">
            <option value="" disabled selected>-- Select a Live Model --</option>
            <option value="genetic">Genetic Model</option>
            <option value="neuro">Neuro Model</option>
            <option value="pathway">Pathway Model</option>
            <option value="synapse">Synapse Model</option>
            <option value="dopamine">Dopamine Signaling Model</option>
            <option value="serotonin">Serotonin Structural Model</option>
            <option value="dna">DNA Repair Model</option>
            <option value="rna">RNA Repair Model</option>
            <option value="emotion">Emotion Model</option>
            <option value="cognition">Cognition Model</option>
            <option value="inflammation">Neuroinflammation Model</option>
            <option value="stress">Stress Dynamics Model</option>
        </select>
        <button id="run-suite-tests" class="btn">Run Suite Tests</button>
        <button id="clear-results" class="btn" style="background-color: #ff9800; color: white;">Clear Results</button>
        <button id="clear-environment" class="btn">Clear Environment</button>
    </div>
    <div id="active-label" style="margin-top:10px; font-size:13px; font-weight:bold; color:#777;">Active Model: None</div>
</header>

<div id="model-container"></div>

<script>
    (function() {
        const modelContainer = document.getElementById('model-container');
        const modelSelector = document.getElementById('model-selector');
        const activeLabel = document.getElementById('active-label');
        const loadingOverlay = document.getElementById('loading-overlay');
        const runTestsBtn = document.getElementById('run-suite-tests');
        const clearResultsBtn = document.getElementById('clear-results');
        const clearBtn = document.getElementById('clear-environment');

        let activeTimers = new window.Set();
        let activeIntervals = new window.Set();
        let activeEventListeners = [];

        function createSandbox(hLog, hError, hWarn, overrides = {}) {
            const sandbox = {
                module: { exports: {} },
                process: {
                    exit: (code) => hLog("[Harness] Process exit intercepted. Code:", code),
                    env: { NODE_ENV: 'test' },
                    nextTick: (fn) => window.setTimeout(fn, 0)
                },
                console: {
                    log: hLog, error: hError, warn: hWarn,
                    info: console.info.bind(console), debug: console.debug.bind(console), table: console.table.bind(console)
                },
                Set: window.Set, Map: window.Map, Promise: window.Promise,
                WeakMap: window.WeakMap, WeakSet: window.WeakSet,
                Uint8Array: window.Uint8Array, Float32Array: window.Float32Array, Int32Array: window.Int32Array,
                Audio: window.Audio, Image: window.Image,
                performance: window.performance, Date: window.Date,
                innerWidth: window.innerWidth, innerHeight: window.innerHeight,
                MutationObserver: window.MutationObserver,
                Node: window.Node,
                HTMLElement: window.HTMLElement
            };

            const defaultLocation = {
                pathname: window.location.pathname,
                search: '', hash: '', hostname: window.location.hostname,
                port: window.location.port, protocol: window.location.protocol,
                origin: window.location.origin, href: window.location.href,
                assign: () => {}, replace: () => {}, reload: () => {}
            };

            const defaultNavigator = {
                userAgent: window.navigator.userAgent,
                platform: window.navigator.platform,
                maxTouchPoints: window.navigator.maxTouchPoints || 0,
                onLine: true
            };

            sandbox.location = { ...defaultLocation, ...(overrides.location || {}) };
            sandbox.navigator = { ...defaultNavigator, ...(overrides.navigator || {}) };

            // Apply other overrides
            for (const k in overrides) {
                if (!['location', 'navigator', 'document', 'window', 'console'].includes(k)) {
                    sandbox[k] = overrides[k];
                }
            }
            if (overrides.window && overrides.window !== window) {
                for (const k in overrides.window) {
                    if (!['location', 'navigator', 'document', 'window', 'console'].includes(k)) {
                        sandbox[k] = overrides.window[k];
                    }
                }
            }
            if (!sandbox.exports) sandbox.exports = sandbox.module.exports;

            const proxy = new Proxy({}, {
                get(target, prop) {
                    if (prop === 'window' || prop === 'global' || prop === 'self' || prop === 'globalThis') return proxy;
                    if (prop === 'document') return sandbox.document;
                    if (prop === '__isProxy') return true;
                    if (prop in sandbox) return sandbox[prop];
                    if (prop in target) return target[prop];

                    const val = window[prop];
                    if (typeof val === 'function' && !/^[A-Z]/.test(prop)) {
                        try { return val.bind(window); } catch(e) { return val; }
                    }
                    return val;
                },
                set(target, prop, value) {
                    sandbox[prop] = value;
                    return true;
                },
                has(target, prop) {
                    return prop === 'window' || prop === 'global' || prop === 'self' || prop === 'globalThis' ||
                           prop in sandbox || prop in target || prop in window;
                },
                getOwnPropertyDescriptor(target, prop) {
                    if (prop in sandbox) return { configurable: true, enumerable: true, value: sandbox[prop], writable: true };
                    if (prop in target) return Object.getOwnPropertyDescriptor(target, prop);
                    const desc = Object.getOwnPropertyDescriptor(window, prop);
                    if (desc && !desc.configurable) return desc;
                    return desc;
                },
                ownKeys(target) {
                    const keys = new window.Set([...Object.keys(sandbox), ...Object.keys(target)]);
                    ['setTimeout', 'clearTimeout'].forEach(k => keys.add(k));
                    return Array.from(keys);
                }
            });

            sandbox.setTimeout = (fn, d, ...a) => {
                const id = window.setTimeout(() => { activeTimers.delete(id); if (typeof fn === 'function') fn(...a); }, d);
                activeTimers.add(id); return id;
            };
            sandbox.clearTimeout = (id) => { window.clearTimeout(id); activeTimers.delete(id); };
            sandbox.setInterval = (fn, d, ...a) => {
                const id = window.setInterval(fn, d, ...a);
                activeIntervals.add(id); return id;
            };
            sandbox.clearInterval = (id) => { window.clearInterval(id); activeIntervals.delete(id); };

            const docSource = overrides.document || window.document;
            sandbox.document = new Proxy(docSource, {
                get(target, prop) {
                    if (prop in sandbox && prop !== 'document') return sandbox[prop];
                    const val = target[prop];
                    if (typeof val === 'function') {
                        const bound = val.bind(target);
                        if (prop === 'addEventListener') {
                            return (t, l, o) => {
                                activeEventListeners.push({ target, type: t, listener: l, options: o });
                                return bound(t, l, o);
                            };
                        }
                        return bound;
                    }
                    return val;
                },
                set(target, prop, value) {
                    sandbox[prop] = value;
                    return true;
                },
                getOwnPropertyDescriptor(target, prop) {
                    if (prop in sandbox && prop !== 'document') return { configurable: true, enumerable: true, value: sandbox[prop], writable: true };
                    const desc = Object.getOwnPropertyDescriptor(target, prop);
                    if (desc) { desc.configurable = true; return desc; }
                    return desc;
                }
            });

            return proxy;
        }

        async function BeforeTest(mockGlobal, modelId) {
            const container = document.getElementById('model-container');
            if (container) container.innerHTML = '';

            mockGlobal.require = (requirePath) => {
                if (requirePath.includes('assertion_library')) return { assert: window.assert, AssertionError: window.AssertionError };
                if (requirePath.includes('test_framework')) return window.TestFramework;
                if (requirePath === 'perf_hooks') return { performance: window.performance };
                if (requirePath === 'fs') return {
                    readFileSync: (p) => {
                        try {
                            const xhr = new XMLHttpRequest();
                            let normalizedPath = p.replace(/^.*docs\/js\//, 'js/').replace(/^.*mobile\/app\//, '../mobile/app/').replace(/^.*utils\//, 'js/').replace(/^\/+/, '');
                            if (!normalizedPath.includes('/') && normalizedPath.endsWith('.js')) normalizedPath = 'js/' + normalizedPath;
                            xhr.open('GET', normalizedPath, false);
                            xhr.send(null);
                            if (xhr.status === 200) return xhr.responseText;
                        } catch (e) { console.error(`[Harness] FS read error for ${p}:`, e); }
                        return '';
                    },
                    existsSync: () => true
                };
                if (requirePath === 'path') return {
                    join: (...args) => args.join('/').replace(/\/+/g, '/'),
                    resolve: (...args) => args.join('/').replace(/\/+/g, '/'),
                    dirname: (p) => p.split('/').slice(0, -1).join('/') || '.'
                };
                if (requirePath === 'vm') return {
                    runInContext: (code, context) => {
                        const fn = new Function("exports", "require", "module", "__filename", "__dirname", "global", "window", "document", "location", "navigator", "with(global) {\n" + code + "\n}");
                        return fn.call(context, context.module.exports, context.require, context.module, context.__filename || '', context.__dirname || '', context, context, context.document, context.location, context.navigator);
                    },
                    runInNewContext: (code, sbox) => {
                        const context = mockGlobal.require('vm').createContext(sbox);
                        return mockGlobal.require('vm').runInContext(code, context);
                    },
                    runInThisContext: (code) => {
                        return mockGlobal.require('vm').runInContext(code, mockGlobal);
                    },
                    createContext: (sbox) => {
                        return createSandbox(mockGlobal.console.log, mockGlobal.console.error, mockGlobal.console.warn, sbox || {});
                    }
                };
                return {};
            };

            mockGlobal.assert = window.assert;
            mockGlobal.AssertionError = window.AssertionError;
            mockGlobal.TestFramework = window.TestFramework;
            mockGlobal.TestFrameworkClass = window.TestFramework ? window.TestFramework.TestFramework : null;
            mockGlobal.GreenhouseTestSuite = window.GreenhouseTestSuite;

            if (modelId === 'neuro') {
                mockGlobal.GreenhouseADHDData = {
                    scenarios: { "default": { "name": "Standard", "description": "Standard", "levels": {} } },
                    adhdTraits: { "impulsivity": 0.5, "inattention": 0.5, "hyperactivity": 0.5 }
                };
            }
        }

        function AfterTest() {
            activeTimers.forEach(id => window.clearTimeout(id));
            activeIntervals.forEach(id => window.clearInterval(id));
            activeTimers.clear(); activeIntervals.clear();
            activeEventListeners.forEach(al => { try { al.target.removeEventListener(al.type, al.listener, al.options); } catch (e) {} });
            activeEventListeners = [];
            const container = document.getElementById('model-container');
            if (container) container.innerHTML = '';
        }

        function clearEnvironment() {
            modelContainer.innerHTML = '';
            document.querySelectorAll('script[data-model-script="true"]').forEach(s => s.remove());
            const overlay = document.getElementById('greenhouse-test-results-overlay');
            if (overlay) overlay.remove();
            activeLabel.textContent = 'Active Model: None';
            modelSelector.value = '';
            AfterTest();
        }

        async function loadModel(modelId) {
            const models = {
                'genetic': { label: 'Genetic Model', js: 'genetic.js' },
                'neuro': { label: 'Neuro Model', js: 'neuro.js' },
                'pathway': { label: 'Pathway Model', js: 'pathway.js' },
                'synapse': { label: 'Synapse Model', js: 'synapse.js' },
                'dopamine': { label: 'Dopamine Signaling Model', js: 'dopamine.js' },
                'serotonin': { label: 'Serotonin Structural Model', js: 'serotonin.js' },
                'dna': { label: 'DNA Repair Model', js: 'dna_repair.js' },
                'rna': { label: 'RNA Repair Model', js: 'rna_repair.js' },
                'emotion': { label: 'Emotion Model', js: 'emotion.js' },
                'cognition': { label: 'Cognition Model', js: 'cognition.js' },
                'inflammation': { label: 'Neuroinflammation Model', js: 'inflammation.js' },
                'stress': { label: 'Stress Dynamics Model', js: 'stress.js' }
            };
            const model = models[modelId];
            if (!model) return;
            clearEnvironment();
            activeLabel.textContent = `Active Model: ${model.label}`;
            modelSelector.value = modelId;
            loadingOverlay.style.display = 'flex';
            await new Promise(resolve => setTimeout(resolve, 3000));
            loadingOverlay.style.display = 'none';

            const section = document.createElement('section'); section.className = 'wixui-section';
            const targetDiv = document.createElement('div'); targetDiv.id = 'model-target';
            section.appendChild(targetDiv);
            modelContainer.appendChild(section);

            const script = document.createElement('script');
            script.src = `js/${model.js}`;
            script.dataset.modelScript = "true";
            const sel = 'section.wixui-section:nth-child(1) > div:nth-child(2) > div:nth-child(1) > section:nth-child(1) > div:nth-child(2)';
            script.setAttribute('data-target-selector-left', sel);
            script.setAttribute('data-base-url', './');
            document.body.appendChild(script);
        }

        modelSelector.addEventListener('change', (e) => loadModel(e.target.value));
        clearBtn.onclick = clearEnvironment;

        runTestsBtn.onclick = async () => {
            const hLog = console.log.bind(console);
            const hError = console.error.bind(console);
            const modelId = modelSelector.value;

            const loadInfra = ['js/assertion_library.js', 'js/test_framework.js', 'js/model_tests.js'];
            for (const src of loadInfra) {
                await new Promise(res => {
                    const s = document.createElement('script');
                    s.src = src; s.onload = res; document.body.appendChild(s);
                });
            }

            if (window.GreenhouseTestSuite) {
                window.GreenhouseTestSuite.tests = [];
                window.GreenhouseTestSuite.runAll = async function() {
                    hLog(`[Harness] runAll() starting. Total tests: ${this.tests.length}`);
                    this.isTesting = true;
                    this.results = [];
                    for (let test of this.tests) {
                        try {
                            const startTime = performance.now();
                            const result = await test.fn();
                            const duration = performance.now() - startTime;
                            this.results.push({ name: test.name, status: 'PASS', duration: duration.toFixed(2) + 'ms', details: result });
                        } catch (error) {
                            hError(`[Harness] Test FAILED: ${test.name}`, error);
                            this.results.push({ name: test.name, status: 'FAIL', error: error.message });
                        }
                    }
                    this.isTesting = false;
                    this.report();
                };
            }

            if (window.TestFramework) {
                window.TestFramework.reset();
                const registeredRepoTests = new window.Set();
                window.TestFramework.it = (name, fn) => {
                    const suite = window.TestFramework.currentSuite;
                    const fullName = `[${suite ? suite.name : 'Unit'}] ${name}`;
                    if (registeredRepoTests.has(fullName)) return;
                    registeredRepoTests.add(fullName);
                    if (window.GreenhouseTestSuite) {
                        window.GreenhouseTestSuite.addTest(fullName, async () => {
                            if (suite && !suite._beforeAllRun) {
                                if (suite.beforeAll) for (const h of suite.beforeAll) await h();
                                suite._beforeAllRun = true;
                            }
                            if (suite && suite.beforeEach) for (const h of suite.beforeEach) await h();
                            try {
                                if (fn.length > 0) await new Promise((resolve, reject) => fn((err) => err ? reject(err) : resolve()));
                                else await fn();
                            } finally {
                                if (suite && suite.afterEach) for (const h of suite.afterEach) await h();
                                AfterTest();
                            }
                        });
                    }
                };
            }

            const testMap = {
                'neuro': ['test_neuro_page.js', 'test_neuro_logic.js', 'test_neuro_ui.js', 'test_neuro_ga.js', 'test_neuro_app_logic.js', 'test_neuro_performance.js', 'test_neuro_3d_engine.js', 'test_neuro_ui_components.js', 'test_neuro_page_loader.js', 'test_adhd_scenarios.js', 'models/auxiliary/test_neuro_page_full.js', 'models/auxiliary/test_neuro_page_new.js'],
                'genetic': ['test_genetic_page.js', 'test_genetic_ui.js', 'test_genetic_algo.js', 'test_genetic_helpers.js', 'test_genetic_labels.js', 'test_genetic_visualizations.js', 'test_genetic_3d_projection.js', 'test_genetic_camera_views.js', 'test_genetic_main_camera_controller.js', 'test_genetic_mouse_actual_bug.js', 'test_genetic_mouse_control_independence.js', 'test_genetic_mouse_event_flow.js', 'test_genetic_pip_camera_usage.js', 'test_genetic_pip_controls.js', 'test_genetic_pip_interactions.js', 'test_genetic_rotation_and_camera_positions.js', 'test_genetic_page_loader.js', 'models/auxiliary/test_genetic_page_new.js']
            };
            const commonTests = ['test_accessibility.js', 'test_assertion_library.js', 'test_dependency_manager.js', 'test_global_ux.js', 'test_greenhouse_utils.js', 'test_labeling_system.js', 'test_models_3d_math.js', 'test_models_toc.js', 'test_models_util.js', 'test_performance_profiler_unit.js', 'test_performance_regression.js', 'test_react_compatibility.js', 'test_test_framework.js', 'test_v8_graph_renderer.js', 'test_mobile_edge_cases.js', 'test_mobile_integration.js', 'test_mobile_model_behaviors.js', 'test_mobile_models_lifecycle.js', 'test_mobile_regression.js', 'test_mobile_typography_contrast.js', 'test_mobile_ui_interactions.js', 'test_mobile_viewer.js', 'test_model_sync.js', 'test_meditation_app.js', 'test_scheduler_logic.js', 'test_tech_canvas.js', 'test_inspiration_logic.js', 'test_patient_app_unit.js', 'test_dashboard_app_unit.js', 'test_kegg_parser.js', 'models/auxiliary/test_models_page_new.js'];

            const testFiles = [...(testMap[modelId] || []), ...commonTests];
            for (const file of testFiles) {
                try {
                    let response = await fetch(`../tests/unit/${file}`);
                    if (!response.ok) response = await fetch(`tests/unit/${file}`);
                    if (!response.ok) continue;
                    const code = await response.text();
                    const currentMockGlobal = createSandbox(hLog, hError, hLog);
                    currentMockGlobal.__filename = file;
                    currentMockGlobal.__dirname = file.split('/').slice(0, -1).join('/') || '.';
                    await BeforeTest(currentMockGlobal, modelId);

                    const vm = currentMockGlobal.require('vm');
                    try { vm.runInContext(code, currentMockGlobal); }
                    catch (e) { hError(`[Harness] Execution error in ${file}:`, e); }
                    hLog(`[Harness] Executed test file: ${file}`);
                } catch (e) { hError(`[Harness] Failed test file: ${file}`, e); }
            }

            if (window.GreenhouseTestSuite) {
                await window.GreenhouseTestSuite.runAll();
            }
        };
    })();
</script>

</body>
</html>
